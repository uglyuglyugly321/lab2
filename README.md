# Лабораторная работа №2 ЯП Java
**Шурманов Демид**

**Группа ИТ-9-2024 (2 курс)**

**Вариант №3**

---

# Тема: Объектно-ориентированное программирование (ООП)

Удобное меню для выбора задачи:
```java
System.out.println("=== Меню ===");
System.out.println("1 — Задание 1 (Имена)");
System.out.println("2 — Задание 2 (Человек)");
System.out.println("3 — Задание 3 (Города)");
System.out.println("4 — Задание 4 (Имена 2)");
System.out.println("5 — Задание 5 (Кот)");

System.out.println("0 — Выход");
System.out.print("Выберите пункт: ");

```

Также предусмотрено предупреждение о неверном вводе пользователем.

---

## Задание 1 (№3):

**Формулировка:**  
```
Имена.
Создайте сущность Имя, которая описывается тремя параметрами: Фамилия, Личное имя,
Отчество.
Имя может быть приведено к строковому виду, включающему традиционное
представление всех трех параметров: Фамилия Имя Отчество (например “Иванов Иван
Иванович”).
Необходимо предусмотреть возможность того, что какой-либо из параметров может
быть не задан, и в этом случае он не учитывается при приведении к текстовому виду.
Необходимо создать следующие имена:
 - Клеопатра
 - Пушкин Александр Сергеевич
 - Маяковский Владимир
Обратите внимание, что при выводе на экран, не заданные параметры никак не участвуют в
образовании строки.
```

# Класс Name 

Эта задача содержит класс `Name`, реализующий простую модель имени человека с поддержкой фамилии, имени и отчества. Класс предназначен для работы с объектами, содержащими эти данные, с возможностью безопасного создания и изменения их значений.  

---

## Описание класса

Класс `Name` хранит три свойства:  

| Поле | Тип | Описание |
|------|-----|----------|
| `lastName` | `String` | Фамилия человека |
| `firstName` | `String` | Имя человека |
| `middleName` | `String` | Отчество человека |

Каждое поле может быть `null`, если значение не указано.  

---

## Конструкторы

Класс содержит три перегруженных конструктора:  

1. **Полный конструктор**  

```java
public Name(String lastName, String firstName, String middleName)
```
Позволяет задать фамилию, имя и отчество одновременно. Если какой-либо аргумент пустой или `null`, соответствующее поле остается `null`.

2.	**Конструктор без отчества**

```java
public Name(String lastName, String firstName)
```
Использует конструктор с тремя параметрами, передавая `null` для отчества.

3. **Конструктор только с именем**

```java
public Name(String firstName)
```
Позволяет создать объект с указанием только имени. Фамилия и отчество будут равны `null`.


---
## Методы доступа (геттеры и сеттеры)
```
Геттеры
	•	getLastName() — возвращает фамилию
	•	getFirstName() — возвращает имя
	•	getMiddleName() — возвращает отчество

Сеттеры
	•	setLastName(String lastName) — изменяет фамилию, если строка не пустая и не null
	•	setFirstName(String firstName) — изменяет имя при тех же условиях
	•	setMiddleName(String middleName) — изменяет отчество при тех же условиях
```
Таким образом, класс защищает себя от присвоения пустых значений полям.

---

## Метод toString
```java
@Override
public String toString()
```
Возвращает строковое представление имени в формате:
```
Фамилия Имя Отчество
```
- Пропускает null поля, чтобы не оставлять лишних пробелов.
- Позволяет красиво отображать объект при выводе.
  
---

## Метод тестирования test
```java
public static void test()
```
Демонстрирует работу класса `Name` и всех его методов.

	Создает три объекта:
	1.	Имя без фамилии и отчества
	2.	Полное имя с фамилией, именем и отчеством
	3.	Имя с фамилией, без отчества
	Выводит их в консоль для проверки корректности работы `toString()`.

## Пример вывода
```
Имена: 
1-ое имя: Клеопатра
2-ое имя: Пушкин Александр Сергеевич
3-ое имя: Маяковский Владимир
```

## Пример использования
```java
public class Main {
    public static void main(String[] args) {
        Name.test();
    }
}
```
Этот код вызовет демонстрацию работы класса, как описано выше.

## Особенности реализации
```
	•	Используется перегрузка конструкторов для удобного создания объектов с разным набором данных.
	•	Сеттеры защищают объект от некорректных значений.
	•	Метод `toString()` строит корректное отображение имени, пропуская отсутствующие части.
```

---

## Задание 2 (№2 и 3):

**Формулировка:**  
```
№2 Объедините сущности Человек из задачи 1.2 и Имя из задачи 1.3 таким образом, чтобы имя
человека задавалось с использованием сущности 1.3, а не строки.
Необходимо объединить ранее созданные объекты имен и людей, с получением:
 Человека с Именем Клеопатра и ростом 152
 Человека с Именем Пушкин Александр Сергеевичи ростом 167
 Человека с Именем Маяковский Владимир и ростом 189

№ 3 Измените сущность Человек из задачи 2.2 добавив ему возможность задавать третий параметр:
Отец, где Отец — это тоже Человек. При приведении человека к строковой форме необходимо
проверить параметры имени, и в зависимости от ситуации выполнить одно из следующих
действий:
 Если у данного человека нет фамилии, и есть отец, у которого фамилия задана, то
фамилию необходимо сделать такой же как у отца.
 Если у данного человека нет отчества, а у отца есть имя, то необходимо задать отчество
как имя отца с добавлением суффикса “ович”
.
Затем необходимо выполнить следующие задачи:
1. Создать людей: Чудова Ивана, Чудова Петра, Бориса
2. Сделать Ивана отцом Петра, а Петра отцом Бориса
3. Вывести на экран строковое представление всех троих людей.
При желании можно попытаться реализовать систему в более полном виде: предусмотреть
разные виды суффиксов отчества в зависимости от окончания имени, а также предусмотреть
возможность задавать пол человека и менять суффикс отчества в зависимости от пола.
```
В данной задаче я объединил два условие в один класс `Human`

## В классе используются три поля:
```
private Name name;   // ФИО человека
private int height;  // Рост
private Human father; // Отец
name — объект класса Name, содержащий фамилию, имя и отчество
height — рост человека
father — ссылка на объект Human, представляющий отца
```

Таким образом реализуется объектная связь человек → отец, что является примером композиции в ООП.

---
**Конструктор класса**

```java
public Human(Name name, int height, Human father) {
    this.name = name;
    this.height = height;
    this.father = father;
}
```
---
**Конструктор позволяет:**
```
- задать имя человека
- указать рост
- при необходимости передать объект отца
```
Это даёт возможность выстраивать цепочку поколений.

---

## Геттер
```java
public Name getName() {
    return name;
}
```

Метод используется для доступа к объекту `Name`, в том числе при формировании фамилии и отчества отца.

## Переопределение метода `toString()`
```java
@Override
public String toString() {
     if (name.getLastName() == null && father != null) {
         name.setLastName(father.getName().getLastName());
     }
     if ((name.getMiddleName() == null && father != null)) {
         name.setMiddleName(father.getName().getFirstName() + "ович");
     }

    return this.name + ", рост: " + this.height;
}
```

В данном методе реализована логика автоматического дополнения ФИО.

## Формирование фамилии
Если фамилия отсутствует, но указан отец — фамилия берётся от отца.
```java
name.setLastName(father.getName().getLastName());
```
## Формирование отчества
Если отчество отсутствует, но указан отец — оно формируется из имени отца.
```java
father.getName().getFirstName() + "ович"
```

## Итоговый вывод

Метод возвращает строку формата:
```
Фамилия Имя Отчество, рост: N
```
Таким образом, `toString()` не просто выводит объект, а логически дополняет данные человека.

## Реализация тестирования
Для проверки работы программы создан статический метод `test()`:
```java
public static void test() {

    Name nameIvan = new Name("Чудов", "Иван", null);
    Name namePetr = new Name("Чудов", "Петр", null);
    Name nameBoris = new Name(null, "Борис", null);

    Human human1 = new Human(nameIvan, 152, null);
    Human human2 = new Human(namePetr, 167, human1);
    Human human3 = new Human(nameBoris, 189, human2);

    System.out.println(human1);
    System.out.println(human2);
    System.out.println(human3);
}
```
Здесь:
- создаются три объекта Name
- создаются три объекта Human
- каждому следующему человеку передаётся отец
- у третьего человека фамилия отсутствует и формируется автоматически

## Тесты
**Тест №1**
```
Чудов Иван, рост: 152
Чудов Петр Иванович, рост: 167
Чудов Борис Петрович, рост: 189
```
Пояснение:

- У первого человека отец отсутствует — данные не изменяются
- У второго формируется отчество от имени отца
- У третьего:
    - фамилия берётся от деда
    - отчество формируется от имени отца
    - демонстрируется наследование данных по цепочке объектов.
---

## Задание 3 (№3):

**Формулировка:**  
```
Создать сущность «Город», которая представляет собой точку на карте и содержит:
название города
набор путей к другим городам
каждый путь — это пара: город + стоимость поездки
Город должен уметь возвращать текстовое представление в формате:
Город -> город 1:стоимость, город 2:стоимость, ...
Используя разработанную сущность, необходимо реализовать схему маршрутов, представленную на рисунке 2.

```

## Проектирование сущности
**Для выполнения задания был создан класс `City`.**

### В классе используются следующие поля:
```java
private String name;
private Map<City, Integer> routes;
name — название города
routes — коллекция маршрутов, где:
ключ — объект City
значение — стоимость пути
```

В качестве структуры данных используется LinkedHashMap, чтобы сохранялся порядок добавления маршрутов.

## Конструктор класса
```java
public City(String name) {
    this.name = name;
    this.routes = new LinkedHashMap<>();
}
```
Конструктор создаёт город с заданным названием и инициализирует пустой список маршрутов.

## Геттеры и методы доступа
**Получение названия города:**
```java
public String getName() {
    return name;
}
```
**Добавление маршрута:**
```java
public void addRoute(City city, int cost) {
    routes.put(city, cost);
}
```

Метод позволяет добавить путь из текущего города в другой город с заданной стоимостью.

Таким образом формируется ориентированный граф, где каждая вершина — это объект `City`.

**Получение всех маршрутов:**
```java
public Map<City, Integer> getRoutes() {
    return routes;
}
```
Метод возвращает все пути, связанные с текущим городом.

## Переопределение метода `toString()`
```java
@Override
public String toString() {
    StringBuilder sb = new StringBuilder(name + " -> ");

    if (routes.isEmpty()) {
        sb.append(name + " не имеет путей");
    }
    else {
        for (Map.Entry<City, Integer> entry : routes.entrySet()) {
            sb.append(entry.getKey().getName())
              .append(":")
              .append(entry.getValue())
              .append(", ");
        }

        sb.setLength(sb.length() - 2);
    }

    return sb.toString();
}
```
Метод формирует строковое представление города.

**Логика работы:**

- если маршрутов нет — выводится сообщение, что город не имеет путей
- если маршруты есть — выводится список всех связанных городов в формате:
```Город -> Название:Стоимость, Название:Стоимость```
- используется StringBuilder для эффективной сборки строки.

## Реализация схемы маршрутов

Для демонстрации работы программы создан метод `test()`:
```java
public static void test() {

    City A = new City("A");
    City B = new City("B");
    City C = new City("C");
    City D = new City("D");
    City E = new City("E");
    City F = new City("F");

    A.addRoute(F, 1);
    A.addRoute(D, 6);
    A.addRoute(B, 5);

    B.addRoute(A, 5);
    B.addRoute(C, 3);

    C.addRoute(D, 4);
    C.addRoute(B, 3);

    D.addRoute(C, 4);
    D.addRoute(A, 6);

    E.addRoute(F, 2);

    F.addRoute(B, 1);
    F.addRoute(E, 2);

    System.out.println(A);
    System.out.println(F);
    System.out.println(B);
    System.out.println(E);
    System.out.println(D);
    System.out.println(C);
}
```

**Здесь:**
- создаются 6 городов
- между ними настраиваются маршруты
- схема соответствует заданной карте
- выводится текстовое представление каждого города

## Тесты
Пример вывода программы:
```
A -> F:1, D:6, B:5
F -> B:1, E:2
B -> A:5, C:3
E -> F:2
D -> C:4, A:6
C -> D:4, B:3
```
## Вывод

В данной задаче была реализована:
- сущность City
- система маршрутов на основе коллекции Map
- модель ориентированного графа
- метод добавления путей
- текстовое представление города и его маршрутов

---

## Задание 4 (№5):

**Формулировка:**  
```
Условие задачи
Изменить сущность «Имя» из задачи 1.3. Новые требования:
- Имя можно создать, указав только личное имя
- Имя можно создать, указав фамилию и личное имя
- Имя можно создать, указав фамилию, личное имя и отчество
Необходимо создать следующие имена:
- Клеопатра
- Александр Сергеевич Пушкин
- Владимир Маяковский
- Христофор Бонифатьевич (где Христофор — имя, Бонифатьевич — фамилия)
```


## Проектирование сущности

Для выполнения задания был создан класс-сущность `Name2`.

В классе используются три поля:
```java
private String lastName;   // Фамилия
private String firstName;  // Имя
private String middleName; // Отчество
```

Данная модель позволяет гибко описывать человека с разным количеством параметров имени.

## Конструкторы класса

Для реализации разных способов создания имени была использована перегрузка конструкторов.

**Конструктор с тремя параметрами**
```java
public Name2(String lastName, String firstName, String middleName) {
    this.lastName = lastName != null && !lastName.isEmpty() ? lastName : null;
    this.firstName = firstName != null && !firstName.isEmpty() ? firstName : null;
    this.middleName = middleName != null && !middleName.isEmpty() ? middleName : null;
}
```
Позволяет задать фамилию, имя и отчество.
Также здесь выполняется проверка на `null` и пустые строки.

**Конструктор с двумя параметрами**
```java
public Name2(String lastName, String firstName) {
    this(lastName, firstName, null);
}
```
Позволяет создать имя без отчества.

**Конструктор с одним параметром**
```java
public Name2(String firstName) {
    this(null, firstName, null);
}
```

Позволяет создать имя, указав только личное имя.

## Сеттеры
В классе реализованы методы для изменения полей, которые:

- не позволяют записать `null`
- не позволяют записать пустую строку

**Пример:**
```java
public void setLastName(String lastName) {
    if (lastName != null && !lastName.isEmpty()) {
        this.lastName = lastName;
    }
}
```
Аналогично реализованы `setFirstName()` и `setMiddleName()`.

## Переопределение метода `toString()`
```java
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();

    if (lastName != null) sb.append(lastName);
    if (firstName != null) {
        if (sb.length() > 0)
            sb.append(" ");
        sb.append(firstName);
    }
    if (middleName != null) {
        if (sb.length() > 0)
            sb.append(" ");
        sb.append(middleName);
    }
    return sb.toString();
}
```

Метод формирует строку, содержащую только те части имени, которые реально заданы.

## Логика работы:
- если поле null — оно не выводится
- между частями автоматически добавляются пробелы
- исключается появление лишних пробелов

**Результат: корректный вывод ФИО в любом варианте инициализации.**

## Реализация тестирования

Для демонстрации работы класса реализован метод `test()`:
```java
public static void test() {
    System.out.println("Имена:");

    Name2 name1 = new Name2("Клеопатра");
    Name2 name2 = new Name2("Пушкин", "Александр", "Сергеевич");
    Name2 name3 = new Name2("Маяковский", "Владимир");
    Name2 name4 = new Name2("Бонифатьевич", "Христофор");

    System.out.println("1. " + name1);
    System.out.println("2. " + name2);
    System.out.println("3. " + name3);
    System.out.println("4. " + name4);
}
```
Создаются объекты в разных вариантах:

- только имя
- фамилия + имя + отчество
- фамилия + имя
- фамилия + имя (по условию задачи)

## Тесты
**Пример вывода программы:**
```
Имена:
1. Клеопатра
2. Пушкин Александр Сергеевич
3. Маяковский Владимир
4. Бонифатьевич Христофор
```
---
## Задание 5 (№2):

**Формулировка:**  
```
Создать сущность «Кот», которая:
- имеет имя (строка)
- создаётся с обязательным указанием имени
- может быть приведена к строковому виду: `Кот: Имя`
может мяукать без параметров:
- Имя: мяу!
может мяукать N раз:
 - Имя: мяу-мяу-...-мяу!
Необходимо создать кота по имени «Барсик», затем:
 - заставить его мяукнуть один раз
 - заставить его мяукнуть три раза
```

## Проектирование сущности
Для выполнения задания был создан класс-сущность `Cat`.

**В классе используется одно поле:**
```java
private String nickname;
nickname — имя кота
```

## Конструктор класса
```java
public Cat(String nickname) {
    this.nickname = nickname;
}
```
Конструктор требует обязательного указания имени кота при создании объекта.
Это исключает возможность существования кота без имени.

## Переопределение метода `toString()`
```java
@Override
public String toString() {
    return "Кот: " + this.nickname;
}
```
Метод возвращает строковое представление кота в формате:
```Кот: Барсик```

## Реализация мяуканья

**Мяуканье без параметров**
```java
public void meow() {
    System.out.println(this.nickname + ": мяу!");
}
```
Метод выводит стандартное мяуканье кота один раз.

## Пример:
```
Барсик: мяу!
```
**Мяуканье N раз (перегрузка метода)**
```java
public void meow(int n) {
    System.out.println(this.nickname + ": ");
    for (int i = 0; i < n; i++) {
        System.out.print("мяу");
        if (i < n - 1) {
            System.out.print("-");
        }
    }
    System.out.println("!");
}
```

Метод реализует перегрузку и позволяет задать количество мяуканий.

## Логика работы:
- запускается цикл на n повторений
- каждое «мяу» разделяется дефисом
- в конце добавляется !

**Пример для n = 3:**
```
Барсик: мяу-мяу-мяу!
```
## Реализация тестирования
Для демонстрации работы создан метод `test()`:
```java
public static void test() {
    Cat cat = new Cat("Барсик");

    System.out.println(cat);
    cat.meow();
    cat.meow(3);
}
```

Здесь:

- создаётся кот по имени «Барсик»
- выводится строковое представление объекта
- вызывается мяуканье без параметров
- вызывается мяуканье три раза
## Тесты
**Пример вывода программы:**
```
Кот: Барсик
Барсик: мяу!
Барсик: 
мяу-мяу-мяу!
```
---

